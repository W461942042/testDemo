# 多线程锁
## 悲观锁和乐观锁
#### 悲观锁：
1. 适合写操作多的场景，先加锁可以保证写操作时数据正确
2. 显示的锁定之后再操作同步资源
3. 一句话：狼性锁
4. synchronized和lock的实现类都是悲观锁。

#### 乐观锁
1. 适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升
2. 乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命。
3. 认为自己在使用数据时不会有别的线程修改数据或资源，所以不会添加锁
 4. 在Java中是通过使用无锁编程来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据
  如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果这个数据已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改，重新抢锁等等

#####判断规则
1. 版本号机制Version
2. 最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

##公平锁和非公平锁
####公平锁
是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾拍着，这是公平的
Lock lock = new ReentrantLock(true);//true 表示公平锁，先来先得


####非公平锁
是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转或者饥饿的状态（某个线程一直得不到锁）
Lock lock = new ReentrantLock(false);//false
Lock lock = new ReentrantLock();//默认非公平锁

####为什么默认非公平锁
1. 恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。
所以非公平锁能更充分的利用CPU的时间片，尽量减少CPU空闲状态时间
2. 使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。



